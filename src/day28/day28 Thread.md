# 进程与线程

- 多个进程的内部数据和状态是相互独立的，多个线程是共享一块内存空间和一组系统资源，有可能相互影响

- 线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以线程的切换比进程切换的负担要小

- 多线程指的是单个程序中可以同时运行多个不同的线程执行不同的任务

- 线程是程序内的顺序控制流，只能分配给程序的资源和环境

- 多线程编程的目的就是最大限度利用CPU资源，当某一个线程不需要占用CPU而只需要I/O等资源打交道，让需要占用CPU资源的线程
有机会获得CPU资源。

- 如果我们没有产生线程，系统自动产生一个主线程，main方法就在主线程运行，我们的程序都是线程来执行的。

- 进程： 执行中的程序，程序是静态的概念，而进程是动态的概念。

## 实现

### 继承Thread类并重写run方法



### 通过定义实现Runnable接口的类进而实现run方法
- 将希望线程执行的代码放到run方法中，通过start方法启动线程，start方法首先为线程的执行准备好系统资源，再调用run。
- 当某个类继承了Thread, 就叫做线程类

- 一个进程至少包含一个进程
- 对于单核CPU来说，某一个时刻只能有一个线程在执行，（微观串行）,从宏观角度，多个线程在同时执行（宏观并行）。

- 对于多核CPU, 可以真正做到微观并行。

- 当生成一个线程对象时，如果没有为其设定名字，则名字将使用如下形式： Thread-number, 该number将是自动增加的，并被所有的
Thread对象所共享（static成员变量）

- 当使用第一个方式来生成对象是，我们需要重写run方法，因为Thread类的run此时什么也不做

- 当使用第二种方式，我们需要实现Runnable接口的run方法，然后使用new Thread(new MyThread())来生成线程对象，这是线程对象的run
方法就会调用MyThread类的run方法，我们自己写的run就执行了。


## 生命周期

- 创建状态
- 可运行状态
- 不可运行状态
- 消亡状态

### 状态转化：
- 开始
- 可运行
- 运行
- 阻塞
- 消亡

- 关于成员变量与局部变量：如果一个变量是成员变量，那么多个线程对同一个对象的成员变量操作，他们对该成员变量是彼此影响的，
而局部变量，那么每个线程都会有一个该局部变量的拷贝，一个线程对该局部变量的改变不会影响到其他线程。

### 停止线程的方式

- 不能使用stop,一般在run方法中设定循环，循环每次查看该变量，如果满足条件继续执行，否则跳出循环
- 不能依靠线程的优先级决定线程的执行顺序


## 多线程的同步

### synchronized 关键字

- 当synchronized修饰一个方法是，该方法叫做同步方法。
- Java中的每个对象都有一个锁（Lock)或者叫做监视器（monitor），当访问某个对象的synchronized方法是，表示将该  **对象**   上锁，
此时其他任何线程都无法再去访问synchronized方法，直到之前那个线程执行方法完毕后，或者抛出了异常，那么将该对象的锁释放，其他线程
才有可能再去访问synchronized方法。
- 如果一个对象有多个synchronized方法，某一时刻某个线程已经进入到了某个synchronized方法，那么该方法没有执行完毕前，
其他线程无法访问该对象的synchronized方法

